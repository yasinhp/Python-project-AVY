# -*- coding: utf-8 -*-
"""Python_project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1T5KyM-jG8CQxq0oNMii38Em6rjix4WvX

remove comment below to download required libraries
"""

#pip install streamlit folium streamlit-folium

# Standard libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import os
import xarray as xr
from IPython.display import display

# Machine Learning libraries
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import r2_score, mean_squared_error

#Mapping

import folium
import geopandas as gpd

import kagglehub

# Download latest version
path = kagglehub.dataset_download("harlfoxem/housesalesprediction")

print("Path to dataset files:", path)

import os

# Your dataset path
dataset_path = "/kaggle/input/housesalesprediction"

# List all files to find the correct CSV file name
print(os.listdir(dataset_path))

df = pd.read_csv(os.path.join(dataset_path, "kc_house_data.csv"))
df.head()  # Show first 5 rows

df.info()

df['date'] = pd.to_datetime(df['date'], format='%Y%m%dT%H%M%S')

# Create new features
df['price_per_sqft'] = df['price'] / df['sqft_living']

df.head()

df.isnull().sum()

# Normalize
# Calculate a normalized investment score based on affordability (inverse of price per square foot)
# and property quality (sum of condition, grade, view, and waterfront). The two components are equally weighted
# using percentile ranks to produce a final score on a 0â€“100 scale.
df['affordability_score'] = 1 / df['price_per_sqft']
df['quality_score'] = df['condition'] + df['grade'] + df['view'] + df['waterfront']

# Combine
df['investment_score'] = (
    df['affordability_score'].rank(pct=True) * 0.5 +
    df['quality_score'].rank(pct=True) * 0.5
) * 100



print(df.columns.tolist())

sns.histplot(df['price'], bins=50, kde=True)
plt.title("Price Distribution")
plt.xlabel("Price ($)")
plt.ylabel("Count")
plt.show()

zip_avg = df.groupby('zipcode')['price'].mean().sort_values(ascending=False)

plt.figure(figsize=(12,6))
zip_avg.head(20).plot(kind='bar', color='teal')
plt.title("Top 20 Zip Codes by Average Price")
plt.ylabel("Average Price ($)")
plt.xlabel("Zip Code")
plt.xticks(rotation=45)
plt.show()

features_to_check = ['price', 'sqft_living', 'sqft_lot', 'bathrooms', 'bedrooms', 'price_per_sqft']

plt.figure(figsize=(15, 10))
for i, feature in enumerate(features_to_check):
    plt.subplot(2, 3, i+1)
    sns.boxplot(x=df[feature])
    plt.title(f'Boxplot: {feature}')
plt.tight_layout()
plt.show()

df.head()

# Feature Engineering:
# Derive additional structural, pricing, and location-based features to enrich the dataset.
# - total_sqft: combined living and lot area
# - house_age: age of the home relative to 2025
# - is_renovated: binary flag for renovated homes
# - price_per_sqft: normalized pricing metric
# - log_price: log transformation for price normalization
# - price_rank_by_zip: percentile-based price rank within each ZIP code
# - property_quality: combined indicator of structural quality and locational desirability

df['total_sqft'] = df['sqft_living'] + df['sqft_lot']
df['house_age'] = 2025 - df['yr_built']
df['is_renovated'] = df['yr_renovated'].apply(lambda x: 1 if x > 0 else 0)

# Pricing Insight
df['price_per_sqft'] = df['price'] / df['sqft_living']
df['log_price'] = np.log1p(df['price'])

# Zipcode-Based (price ranking)
df['price_rank_by_zip'] = df.groupby('zipcode')['price'].rank(pct=True)

# Composite Score Idea (just for fun)
df['property_quality'] = df['grade'] + df['condition'] + df['view'] + df['waterfront']

sns.histplot(df['price_per_sqft'], kde=True, bins=50, color='teal')
plt.title("Price Per Square Foot Distribution")
plt.xlabel("Price per SqFt ($)")
plt.ylabel("Number of Properties")
plt.show()

features_to_keep = [
    'date', 'price', 'bedrooms', 'bathrooms', 'sqft_living', 'floors',
    'waterfront', 'view', 'condition', 'grade','yr_built','yr_renovated','zipcode', 'lat', 'long',
    'price_per_sqft', 'affordability_score', 'quality_score', 'investment_score'
]

df_filtered = df[features_to_keep]

"""downaload data"""

#df_filtered.to_csv("filtered_real_estate_data.csv", index=False)
#from google.colab import files
#files.download("filtered_real_estate_data.csv")

df_filtered.info()
df_filtered.describe().T

plt.figure(figsize=(10,5))
sns.histplot(df_filtered['price'], bins=50, kde=True)
plt.title("Price Distribution")
plt.show()

plt.figure(figsize=(10,5))
sns.histplot(df_filtered['investment_score'], bins=50, kde=True, color='green')
plt.title("Investment Score Distribution")
plt.show()

zip_investment = df_filtered.groupby("zipcode")["investment_score"].mean().sort_values(ascending=False).head(10)

zip_investment.plot(kind='barh', color='orange', figsize=(10,5))
plt.title("Top 10 ZIP Codes by Avg Investment Score")
plt.xlabel("Investment Score")
plt.ylabel("ZIP Code")
plt.gca().invert_yaxis()
plt.show()

plt.figure(figsize=(12,8))
sns.heatmap(df_filtered.corr(numeric_only=True), annot=True, cmap='coolwarm')
plt.title("Correlation Heatmap")
plt.show()

plt.figure(figsize=(10,6))
sns.scatterplot(data=df_filtered, x="sqft_living", y="price", hue="investment_score", palette="viridis")
plt.title("Price vs Living Area Colored by Investment Score")
plt.show()

plt.figure(figsize=(15, 6))
ax = sns.barplot(x=top_zipcodes.values, y=[str(i) for i in range(len(top_zipcodes))], palette="magma")

# Annotate each bar with the ZIP code above the bar
for i, (score, zipcode) in enumerate(zip(top_zipcodes.values, top_zipcodes.index)):
    ax.text(score, i, f"{zipcode}", va='center', ha='left', fontsize=10, color='black')

# Customize labels and title
plt.xlabel("Average Investment Score")
plt.ylabel("")
ax.set_yticklabels([])  # Remove y-axis ticks
plt.title("Top 10 Zip Codes by Investment Score")
plt.tight_layout()
plt.show()

plt.figure(figsize=(10,6))
sns.scatterplot(x='investment_score', y='price', data=df, alpha=0.5)
plt.title("Price vs Investment Score")
plt.xlabel("Investment Score")
plt.ylabel("Price")
plt.tight_layout()
plt.show()